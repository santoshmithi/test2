You're right - we can make this cleaner by using a single CASE statement per exposure type that returns a JSON object containing all related fields. Here's the improved version:

Optimized Stored Procedure
sql
CREATE OR ALTER PROCEDURE dbo.GetBenchmarksWithDynamicExposures
    @First INT = NULL,
    @After NVARCHAR(50) = NULL,
    @RequestedExposures NVARCHAR(MAX) -- JSON: ['Country','Currency','Composition']
AS
BEGIN
    -- Parse requested exposures
    DECLARE @FetchCountry BIT = 0, @FetchCurrency BIT = 0, @FetchComposition BIT = 0;
    
    SELECT 
        @FetchCountry = CASE WHEN EXISTS (SELECT 1 FROM OPENJSON(@RequestedExposures) WHERE value = 'Country') THEN 1 ELSE 0 END,
        @FetchCurrency = CASE WHEN EXISTS (SELECT 1 FROM OPENJSON(@RequestedExposures) WHERE value = 'Currency') THEN 1 ELSE 0 END,
        @FetchComposition = CASE WHEN EXISTS (SELECT 1 FROM OPENJSON(@RequestedExposures) WHERE value = 'Composition') THEN 1 ELSE 0 END;

    -- Get paginated benchmarks
    WITH LatestBenchmarks AS (
        SELECT 
            b.*,
            ROW_NUMBER() OVER (ORDER BY b.IndexSymbol) AS RowNum
        FROM (
            SELECT 
                b.IndexSymbol,
                b.ValueDate,
                b.IndexCurrency,
                b.IndexSource,
                b.MessageGuid,
                ROW_NUMBER() OVER (
                    PARTITION BY b.IndexSymbol 
                    ORDER BY b.ValueDate DESC, b.ExecutedDateTime DESC
                ) AS LatestRow
            FROM Benchmarks b
        ) b
        WHERE b.LatestRow = 1
        AND (@After IS NULL OR b.IndexSymbol > @After)
    )
    
    -- Return benchmark data with requested exposures
    SELECT 
        b.IndexSymbol,
        b.ValueDate,
        b.IndexCurrency,
        b.IndexSource,
        b.MessageGuid,
        -- Single CASE for all Country exposure data
        CASE WHEN @FetchCountry = 1 THEN 
            (SELECT 
                co.Country AS country,
                co.Weight AS weight,
                co.ExtractedDateTime AS extractedDateTime,
                co.ImportDate AS importDate
             FROM (
                 SELECT 
                     wa.Country,
                     wa.Weight,
                     wa.ExtractedDateTime,
                     wa.ImportDate,
                     ROW_NUMBER() OVER (PARTITION BY wa.ParentSymbol, wa.ValueDate ORDER BY wa.ExtractedDateTime DESC) AS RowNum
                 FROM WeightAllocation wa
                 WHERE wa.ParentSymbol = b.IndexSymbol 
                 AND wa.ValueDate = b.ValueDate 
                 AND wa.Country IS NOT NULL
             ) co
             WHERE co.RowNum = 1
             FOR JSON PATH, WITHOUT_ARRAY_WRAPPER)
        ELSE NULL END AS CountryExposure,
        -- Single CASE for all Currency exposure data
        CASE WHEN @FetchCurrency = 1 THEN 
            (SELECT 
                cu.Currency AS currency,
                cu.Weight AS weight,
                cu.ExtractedDateTime AS extractedDateTime,
                cu.ImportDate AS importDate
             FROM (
                 SELECT 
                     wa.Currency,
                     wa.Weight,
                     wa.ExtractedDateTime,
                     wa.ImportDate,
                     ROW_NUMBER() OVER (PARTITION BY wa.ParentSymbol, wa.ValueDate ORDER BY wa.ExtractedDateTime DESC) AS RowNum
                 FROM WeightAllocation wa
                 WHERE wa.ParentSymbol = b.IndexSymbol 
                 AND wa.ValueDate = b.ValueDate 
                 AND wa.Currency IS NOT NULL
             ) cu
             WHERE cu.RowNum = 1
             FOR JSON PATH, WITHOUT_ARRAY_WRAPPER)
        ELSE NULL END AS CurrencyExposure,
        -- Single CASE for all Composition data
        CASE WHEN @FetchComposition = 1 THEN 
            (SELECT 
                cp.Sector AS sector,
                cp.Industry AS industry,
                cp.ExtractedDateTime AS extractedDateTime
             FROM (
                 SELECT 
                     c.Sector,
                     c.Industry,
                     c.ExtractedDateTime,
                     ROW_NUMBER() OVER (PARTITION BY c.ParentSymbol, c.ValueDate ORDER BY c.ExtractedDateTime DESC) AS RowNum
                 FROM Composition c
                 WHERE c.ParentSymbol = b.IndexSymbol 
                 AND c.ValueDate = b.ValueDate
             ) cp
             WHERE cp.RowNum = 1
             FOR JSON PATH, WITHOUT_ARRAY_WRAPPER)
        ELSE NULL END AS CompositionExposure
    FROM (
        SELECT * FROM LatestBenchmarks 
        WHERE @First IS NULL OR RowNum <= @First
    ) b
    ORDER BY b.IndexSymbol;
END
Updated ExposerService Class
csharp
public class ExposerService
{
    private readonly DbContext _dbContext;
    
    public ExposerService(DbContext dbContext)
    {
        _dbContext = dbContext;
    }

    public async Task<IEnumerable<BenchmarkQl>> GetBenchmarksWithExposures(
        int? first, 
        string? after,
        List<string> requestedExposures)
    {
        var requestedExposuresJson = JsonSerializer.Serialize(requestedExposures);

        var connection = _dbContext.Database.GetDbConnection();
        var command = connection.CreateCommand();
        command.CommandText = "EXEC dbo.GetBenchmarksWithDynamicExposures @First, @After, @RequestedExposures";
        
        command.Parameters.Add(new SqlParameter("@First", first ?? (object)DBNull.Value));
        command.Parameters.Add(new SqlParameter("@After", after ?? (object)DBNull.Value));
        command.Parameters.Add(new SqlParameter("@RequestedExposures", requestedExposuresJson));

        await connection.OpenAsync();
        var reader = await command.ExecuteReaderAsync();

        var benchmarks = new List<BenchmarkQl>();
        
        while (await reader.ReadAsync())
        {
            var benchmark = new BenchmarkQl
            {
                IndexSymbol = reader.GetString(0),
                ValueDate = reader.GetDateTime(1),
                IndexCurrency = reader.GetString(2),
                IndexSource = reader.GetString(3),
                MessageGuid = reader.GetGuid(4),
                CountryExposures = new List<CountryExposerQl>(),
                CurrencyExposures = new List<CurrencyExposerQl>(),
                CompositionExposures = new List<CompositionExposerQl>()
            };

            // Process Country Exposure JSON
            if (requestedExposures.Contains("Country") && !reader.IsDBNull(5))
            {
                var countryJson = reader.GetString(5);
                var countryData = JsonSerializer.Deserialize<CountryExposerQl>(countryJson);
                countryData.Valuedate = benchmark.ValueDate;
                countryData.MessageGuid = benchmark.MessageGuid;
                benchmark.CountryExposures.Add(countryData);
            }

            // Process Currency Exposure JSON
            if (requestedExposures.Contains("Currency") && !reader.IsDBNull(6))
            {
                var currencyJson = reader.GetString(6);
                var currencyData = JsonSerializer.Deserialize<CurrencyExposerQl>(currencyJson);
                currencyData.Valuedate = benchmark.ValueDate;
                currencyData.MessageGuid = benchmark.MessageGuid;
                benchmark.CurrencyExposures.Add(currencyData);
            }

            // Process Composition JSON
            if (requestedExposures.Contains("Composition") && !reader.IsDBNull(7))
            {
                var compositionJson = reader.GetString(7);
                var compositionData = JsonSerializer.Deserialize<CompositionExposerQl>(compositionJson);
                compositionData.Valuedate = benchmark.ValueDate;
                compositionData.MessageGuid = benchmark.MessageGuid;
                benchmark.CompositionExposures.Add(compositionData);
            }

            benchmarks.Add(benchmark);
        }

        await reader.CloseAsync();
        await connection.CloseAsync();
        return benchmarks;
    }
}
