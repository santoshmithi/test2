You're right! Since IDataReaderWrapper is our custom interface, we need to add the IsDBNull method to it. Here's how we should update the interface and implementations:

Update the Interfaces
csharp
public interface IDataReaderWrapper : IDisposable
{
    Task<bool> ReadAsync();
    object this[string name] { get; }
    int GetOrdinal(string name);
    T GetFieldValue<T>(int ordinal);
    bool IsDBNull(int ordinal); // Add this method
}
Update the Implementation
csharp
public class DataReaderWrapper : IDataReaderWrapper
{
    private readonly DbDataReader _reader;

    public DataReaderWrapper(DbDataReader reader)
    {
        _reader = reader ?? throw new ArgumentNullException(nameof(reader));
    }

    public async Task<bool> ReadAsync() => await _reader.ReadAsync();
    public object this[string name] => _reader[name];
    public int GetOrdinal(string name) => _reader.GetOrdinal(name);
    public T GetFieldValue<T>(int ordinal) => _reader.GetFieldValue<T>(ordinal);
    public bool IsDBNull(int ordinal) => _reader.IsDBNull(ordinal); // Implement the method
    public void Dispose() => _reader.Dispose();
}
Update the Extension Methods
Now we can update our extension methods to use the interface's IsDBNull method:

csharp
public static class DataReaderExtensions
{
    public static T GetNullableFieldValue<T>(this IDataReaderWrapper reader, int ordinal) where T : class
    {
        return reader.IsDBNull(ordinal) ? null : reader.GetFieldValue<T>(ordinal);
    }

    public static T? GetNullableFieldValue<T>(this IDataReaderWrapper reader, int ordinal) where T : struct
    {
        return reader.IsDBNull(ordinal) ? (T?)null : reader.GetFieldValue<T>(ordinal);
    }
}
Update the Usage in Service
Now you can use either the direct approach or the extension methods:

csharp
// Direct approach
while (await reader.ReadAsync())
{
    var benchQLs = new BenchQL
    {
        Id = reader.IsDBNull(idOrdinal) ? 0 : reader.GetFieldValue<int>(idOrdinal),
        Name = reader.IsDBNull(nameOrdinal) ? null : reader.GetFieldValue<string>(nameOrdinal)
    };
    benchQLvar.Add(benchQLs);
}

// Or using extension methods
while (await reader.ReadAsync())
{
    var benchQLs = new BenchQL
    {
        Id = reader.GetFieldValue<int>(idOrdinal), // Not nullable
        Name = reader.GetNullableFieldValue<string>(nameOrdinal),
        Amount = reader.GetNullableFieldValue<decimal>(amountOrdinal)
    };
    benchQLvar.Add(benchQLs);
}
Update the Unit Tests
Make sure your mock setup includes the new method:

csharp
// In your test setup
_readerMock.Setup(r => r.IsDBNull(It.IsAny<int>()))
    .Returns<int>(ordinal => 
    {
        // Your logic to determine which columns should be null
        if (ordinal == nameOrdinal) return true; // Name is null
        if (ordinal == descriptionOrdinal) return true; // Description is null
        return false; // Other columns are not null
    });

------------------------------------------

I'll modify the code to properly handle null values when reading from the data reader. Here's how we can implement the null checks for each field:

csharp
while (await reader.ReadAsync())
{
    var benchQLs = new BenchQL
    {
        Id = reader.IsDBNull(idOrdinal) ? 0 : reader.GetFieldValue<int>(idOrdinal),
        Name = reader.IsDBNull(nameOrdinal) ? null : reader.GetFieldValue<string>(nameOrdinal),
        // Other properties with null checks
        Description = reader.IsDBNull(descriptionOrdinal) ? null : reader.GetFieldValue<string>(descriptionOrdinal),
        Amount = reader.IsDBNull(amountOrdinal) ? (decimal?)null : reader.GetFieldValue<decimal>(amountOrdinal),
        DateCreated = reader.IsDBNull(dateCreatedOrdinal) ? (DateTime?)null : reader.GetFieldValue<DateTime>(dateCreatedOrdinal)
    };
    benchQLvar.Add(benchQLs);
}
To make this more maintainable and reduce repetitive code, we can create extension methods for the IDataReaderWrapper:

csharp
public static class DataReaderExtensions
{
    public static T GetNullableFieldValue<T>(this IDataReaderWrapper reader, int ordinal) where T : class
    {
        return reader.IsDBNull(ordinal) ? null : reader.GetFieldValue<T>(ordinal);
    }

    public static T? GetNullableFieldValue<T>(this IDataReaderWrapper reader, int ordinal) where T : struct
    {
        return reader.IsDBNull(ordinal) ? (T?)null : reader.GetFieldValue<T>(ordinal);
    }
}
Then the reading code becomes cleaner:

csharp
while (await reader.ReadAsync())
{
    var benchQLs = new BenchQL
    {
        Id = reader.GetFieldValue<int>(idOrdinal), // Assuming Id is not nullable
        Name = reader.GetNullableFieldValue<string>(nameOrdinal),
        Description = reader.GetNullableFieldValue<string>(descriptionOrdinal),
        Amount = reader.GetNullableFieldValue<decimal>(amountOrdinal),
        DateCreated = reader.GetNullableFieldValue<DateTime>(dateCreatedOrdinal)
    };
    benchQLvar.Add(benchQLs);
}
For the unit tests, we should add test cases for null values:

csharp
[Test]
public async Task GetBenchDetails_ShouldHandleNullValues()
{
    // Arrange
    var testId = 1;
    var readSequence = _readerMock.SetupSequence(r => r.ReadAsync());
    readSequence.ReturnsAsync(true); // Row with null values
    readSequence.ReturnsAsync(false); // End of data

    _readerMock.Setup(r => r.GetOrdinal("Id")).Returns(0);
    _readerMock.Setup(r => r.GetOrdinal("Name")).Returns(1);
    _readerMock.Setup(r => r.GetOrdinal("Description")).Returns(2);
    _readerMock.Setup(r => r.GetOrdinal("Amount")).Returns(3);
    _readerMock.Setup(r => r.GetOrdinal("DateCreated")).Returns(4);

    // Setup null values
    _readerMock.Setup(r => r.IsDBNull(0)).Returns(false);
    _readerMock.Setup(r => r.IsDBNull(1)).Returns(true); // Name is null
    _readerMock.Setup(r => r.IsDBNull(2)).Returns(true); // Description is null
    _readerMock.Setup(r => r.IsDBNull(3)).Returns(false);
    _readerMock.Setup(r => r.IsDBNull(4)).Returns(true); // DateCreated is null

    _readerMock.Setup(r => r.GetFieldValue<int>(0)).Returns(1);
    _readerMock.Setup(r => r.GetFieldValue<decimal>(3)).Returns(100.50m);

    // Act
    var result = await _service.GetBenchDetails(testId);
    var firstItem = result.First();

    // Assert
    Assert.AreEqual(1, firstItem.Id);
    Assert.IsNull(firstItem.Name);
    Assert.IsNull(firstItem.Description);
    Assert.AreEqual(100.50m, firstItem.Amount);
    Assert.IsNull(firstItem.DateCreated);
}
This approach provides:

Proper null handling for all database fields

Cleaner code through extension methods

Comprehensive test coverage for null values

Type safety with generic methods

=============


I'll create proper wrappers for the database operations and then write unit tests using NUnit. This will help mock the database interactions effectively.

First, let's create the necessary wrappers:
csharp
public interface IDatabaseConnection
{
    Task OpenAsync();
    Task CloseAsync();
    IDbCommand CreateCommand();
}

public interface IDbCommandWrapper
{
    CommandType CommandType { get; set; }
    string CommandText { get; set; }
    Task<IDataReaderWrapper> ExecuteReaderAsync();
    void AddParameter(string name, object value);
}

public interface IDataReaderWrapper : IDisposable
{
    Task<bool> ReadAsync();
    object this[string name] { get; }
    int GetOrdinal(string name);
    T GetFieldValue<T>(int ordinal);
}

// Implementations
public class DatabaseConnectionWrapper : IDatabaseConnection
{
    private readonly DbConnection _connection;

    public DatabaseConnectionWrapper(DbConnection connection)
    {
        _connection = connection ?? throw new ArgumentNullException(nameof(connection));
    }

    public async Task OpenAsync() => await _connection.OpenAsync();
    public async Task CloseAsync() => await _connection.CloseAsync();
    public IDbCommand CreateCommand() => _connection.CreateCommand();
}

public class DbCommandWrapper : IDbCommandWrapper
{
    private readonly IDbCommand _command;

    public DbCommandWrapper(IDbCommand command)
    {
        _command = command ?? throw new ArgumentNullException(nameof(command));
    }

    public CommandType CommandType 
    {
        get => _command.CommandType;
        set => _command.CommandType = value;
    }

    public string CommandText 
    {
        get => _command.CommandText;
        set => _command.CommandText = value;
    }

    public async Task<IDataReaderWrapper> ExecuteReaderAsync()
    {
        var dbCommand = _command as DbCommand;
        if (dbCommand == null)
            throw new InvalidOperationException("Command must be a DbCommand for async operations");
            
        var reader = await dbCommand.ExecuteReaderAsync();
        return new DataReaderWrapper(reader);
    }

    public void AddParameter(string name, object value)
    {
        var parameter = _command.CreateParameter();
        parameter.ParameterName = name;
        parameter.Value = value ?? DBNull.Value;
        _command.Parameters.Add(parameter);
    }
}

public class DataReaderWrapper : IDataReaderWrapper
{
    private readonly DbDataReader _reader;

    public DataReaderWrapper(DbDataReader reader)
    {
        _reader = reader ?? throw new ArgumentNullException(nameof(reader));
    }

    public async Task<bool> ReadAsync() => await _reader.ReadAsync();
    public object this[string name] => _reader[name];
    public int GetOrdinal(string name) => _reader.GetOrdinal(name);
    public T GetFieldValue<T>(int ordinal) => _reader.GetFieldValue<T>(ordinal);
    public void Dispose() => _reader.Dispose();
}
Now, let's modify the exposer service to use these wrappers:
csharp
public class ExposerService
{
    private readonly IDbContexProvider _dbContexProvider;
    private readonly IDatabaseConnectionFactory _connectionFactory;

    public ExposerService(IDbContexProvider dbContexProvider, IDatabaseConnectionFactory connectionFactory)
    {
        _dbContexProvider = dbContexProvider;
        _connectionFactory = connectionFactory;
    }

    public async Task<IEnumerable<BenchQL>> GetBenchDetails(int id)
    {
        var benchQLvar = new List<BenchQL>();
        var connection = _connectionFactory.CreateConnection(_dbContexProvider.GetDbConnection());

        try
        {
            await connection.OpenAsync();
            var command = connection.CreateCommand();
            var commandWrapper = new DbCommandWrapper(command);
            
            commandWrapper.CommandType = CommandType.StoredProcedure;
            commandWrapper.CommandText = "prcname";
            commandWrapper.AddParameter("id", id);

            using (var reader = await commandWrapper.ExecuteReaderAsync())
            {
                // Get column ordinals first
                var idOrdinal = reader.GetOrdinal("Id");
                var nameOrdinal = reader.GetOrdinal("Name");
                // Add other columns as needed

                while (await reader.ReadAsync())
                {
                    var benchQLs = new BenchQL
                    {
                        Id = reader.GetFieldValue<int>(idOrdinal),
                        Name = reader.GetFieldValue<string>(nameOrdinal),
                        // fill other properties
                    };
                    benchQLvar.Add(benchQLs);
                }
            }
        }
        finally
        {
            await connection.CloseAsync();
        }

        return benchQLvar;
    }

    public IQueryable<SomeClass> GetSomeDataForThis()
    {
        return _dbContexProvider.GetBenchDBcontex().ModelTableData;
    }
}

// Additional interface needed
public interface IDatabaseConnectionFactory
{
    IDatabaseConnection CreateConnection(DbConnection connection);
}

public class DatabaseConnectionFactory : IDatabaseConnectionFactory
{
    public IDatabaseConnection CreateConnection(DbConnection connection)
    {
        return new DatabaseConnectionWrapper(connection);
    }
}
Now, let's create the unit tests using NUnit:
csharp
using NUnit.Framework;
using Moq;
using System.Data;
using System.Data.Common;
using System.Threading.Tasks;
using System.Collections.Generic;

[TestFixture]
public class ExposerServiceTests
{
    private Mock<IDbContexProvider> _dbContextProviderMock;
    private Mock<IDatabaseConnectionFactory> _connectionFactoryMock;
    private Mock<IDatabaseConnection> _connectionMock;
    private Mock<IDbCommandWrapper> _commandMock;
    private Mock<IDataReaderWrapper> _readerMock;
    private ExposerService _service;

    [SetUp]
    public void Setup()
    {
        _dbContextProviderMock = new Mock<IDbContexProvider>();
        _connectionFactoryMock = new Mock<IDatabaseConnectionFactory>();
        _connectionMock = new Mock<IDatabaseConnection>();
        _commandMock = new Mock<IDbCommandWrapper>();
        _readerMock = new Mock<IDataReaderWrapper>();

        _connectionFactoryMock.Setup(f => f.CreateConnection(It.IsAny<DbConnection>()))
            .Returns(_connectionMock.Object);

        _connectionMock.Setup(c => c.CreateCommand())
            .Returns(_commandMock.Object);

        _commandMock.Setup(c => c.ExecuteReaderAsync())
            .ReturnsAsync(_readerMock.Object);

        _service = new ExposerService(
            _dbContextProviderMock.Object,
            _connectionFactoryMock.Object);
    }

    [Test]
    public async Task GetBenchDetails_ShouldReturnData_WhenProcedureExecutesSuccessfully()
    {
        // Arrange
        var testId = 1;
        var expectedResults = new List<BenchQL>
        {
            new BenchQL { Id = 1, Name = "Test 1" },
            new BenchQL { Id = 2, Name = "Test 2" }
        };

        var readSequence = _readerMock.SetupSequence(r => r.ReadAsync());
        readSequence.ReturnsAsync(true); // First row
        readSequence.ReturnsAsync(true); // Second row
        readSequence.ReturnsAsync(false); // End of data

        _readerMock.Setup(r => r.GetOrdinal("Id")).Returns(0);
        _readerMock.Setup(r => r.GetOrdinal("Name")).Returns(1);
        
        _readerMock.Setup(r => r.GetFieldValue<int>(0))
            .Returns<int>(i => expectedResults[i].Id);
        _readerMock.Setup(r => r.GetFieldValue<string>(1))
            .Returns<int>(i => expectedResults[i].Name);

        // Act
        var result = await _service.GetBenchDetails(testId);

        // Assert
        Assert.IsNotNull(result);
        Assert.AreEqual(2, result.Count());
        Assert.AreEqual("Test 1", result.First().Name);

        // Verify command was set up correctly
        _commandMock.VerifySet(c => c.CommandType = CommandType.StoredProcedure);
        _commandMock.VerifySet(c => c.CommandText = "prcname");
        _commandMock.Verify(c => c.AddParameter("id", testId), Times.Once);

        // Verify connection was opened and closed
        _connectionMock.Verify(c => c.OpenAsync(), Times.Once);
        _connectionMock.Verify(c => c.CloseAsync(), Times.Once);
    }

    [Test]
    public void GetBenchDetails_ShouldThrow_WhenConnectionFails()
    {
        // Arrange
        var testId = 1;
        _connectionMock.Setup(c => c.OpenAsync())
            .ThrowsAsync(new Exception("Connection failed"));

        // Act & Assert
        Assert.ThrowsAsync<Exception>(() => _service.GetBenchDetails(testId));
    }

    [Test]
    public async Task GetBenchDetails_ShouldReturnEmpty_WhenNoData()
    {
        // Arrange
        var testId = 1;
        _readerMock.Setup(r => r.ReadAsync()).ReturnsAsync(false);

        // Act
        var result = await _service.GetBenchDetails(testId);

        // Assert
        Assert.IsNotNull(result);
        Assert.IsEmpty(result);
    }

    [Test]
    public void GetSomeDataForThis_ShouldReturnQueryable()
    {
        // Arrange
        var mockDbSet = new Mock<DbSet<SomeClass>>();
        var mockContext = new Mock<benchDBcontex>();
        
        mockContext.Setup(c => c.ModelTableData).Returns(mockDbSet.Object);
        _dbContextProviderMock.Setup(p => p.GetBenchDBcontex()).Returns(mockContext.Object);

        // Act
        var result = _service.GetSomeDataForThis();

        // Assert
        Assert.IsNotNull(result);
        _dbContextProviderMock.Verify(p => p.GetBenchDBcontex(), Times.Once);
    }
}
