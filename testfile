using NUnit.Framework;
using Moq;
using System.Data;
using System.Data.Common;
using Microsoft.EntityFrameworkCore;
using System.Threading.Tasks;

[TestFixture]
public class WrapperTests
{
    #region DbContexProvider Tests

    [Test]
    public void DbContexProvider_ShouldReturnDbContext()
    {
        // Arrange
        var mockDbContext = new Mock<benchDBcontex>();
        var provider = new DbContexProvider(mockDbContext.Object);

        // Act
        var result = provider.GetBenchDBcontex();

        // Assert
        Assert.That(result, Is.EqualTo(mockDbContext.Object));
    }

    [Test]
    public void DbContexProvider_ShouldReturnDbConnection()
    {
        // Arrange
        var mockConnection = new Mock<DbConnection>();
        var mockDbContext = new Mock<benchDBcontex>();
        mockDbContext.Setup(d => d.Database.GetDbConnection()).Returns(mockConnection.Object);
        
        var provider = new DbContexProvider(mockDbContext.Object);

        // Act
        var result = provider.GetDbConnection();

        // Assert
        Assert.That(result, Is.EqualTo(mockConnection.Object));
    }

    #endregion

    #region DatabaseConnectionWrapper Tests

    [Test]
    public async Task DatabaseConnectionWrapper_ShouldOpenAndCloseConnection()
    {
        // Arrange
        var mockConnection = new Mock<DbConnection>();
        var wrapper = new DatabaseConnectionWrapper(mockConnection.Object);

        // Act
        await wrapper.OpenAsync();
        await wrapper.CloseAsync();

        // Assert
        mockConnection.Verify(c => c.OpenAsync(), Times.Once);
        mockConnection.Verify(c => c.CloseAsync(), Times.Once);
    }

    [Test]
    public void DatabaseConnectionWrapper_CreateCommand_ShouldReturnCommand()
    {
        // Arrange
        var mockCommand = new Mock<IDbCommand>();
        var mockConnection = new Mock<DbConnection>();
        mockConnection.Setup(c => c.CreateCommand()).Returns(mockCommand.Object);
        
        var wrapper = new DatabaseConnectionWrapper(mockConnection.Object);

        // Act
        var result = wrapper.CreateCommand();

        // Assert
        Assert.That(result, Is.EqualTo(mockCommand.Object));
    }

    [Test]
    public void DatabaseConnectionWrapper_CreateWrappedCommand_ShouldReturnWrapper()
    {
        // Arrange
        var mockCommand = new Mock<IDbCommand>();
        var mockConnection = new Mock<DbConnection>();
        mockConnection.Setup(c => c.CreateCommand()).Returns(mockCommand.Object);
        
        var wrapper = new DatabaseConnectionWrapper(mockConnection.Object);

        // Act
        var result = wrapper.CreateWrappedCommand();

        // Assert
        Assert.That(result, Is.InstanceOf<DbCommandWrapper>());
    }

    [Test]
    public void DatabaseConnectionWrapper_Dispose_ShouldDisposeConnection()
    {
        // Arrange
        var mockConnection = new Mock<DbConnection>();
        var wrapper = new DatabaseConnectionWrapper(mockConnection.Object);

        // Act
        wrapper.Dispose();

        // Assert
        mockConnection.Verify(c => c.Dispose(), Times.Once);
    }

    #endregion

    #region DataReaderWrapper Tests

    [Test]
    public async Task DataReaderWrapper_ReadAsync_ShouldCallUnderlyingReader()
    {
        // Arrange
        var mockReader = new Mock<DbDataReader>();
        mockReader.Setup(r => r.ReadAsync(default)).ReturnsAsync(true);
        
        var wrapper = new DataReaderWrapper(mockReader.Object);

        // Act
        var result = await wrapper.ReadAsync();

        // Assert
        Assert.That(result, Is.True);
        mockReader.Verify(r => r.ReadAsync(default), Times.Once);
    }

    [Test]
    public void DataReaderWrapper_Indexer_ShouldReturnValue()
    {
        // Arrange
        var mockReader = new Mock<DbDataReader>();
        mockReader.Setup(r => r["test"]).Returns("value");
        
        var wrapper = new DataReaderWrapper(mockReader.Object);

        // Act
        var result = wrapper["test"];

        // Assert
        Assert.That(result, Is.EqualTo("value"));
    }

    [Test]
    public void DataReaderWrapper_GetOrdinal_ShouldReturnPosition()
    {
        // Arrange
        var mockReader = new Mock<DbDataReader>();
        mockReader.Setup(r => r.GetOrdinal("name")).Returns(1);
        
        var wrapper = new DataReaderWrapper(mockReader.Object);

        // Act
        var result = wrapper.GetOrdinal("name");

        // Assert
        Assert.That(result, Is.EqualTo(1));
    }

    [Test]
    public void DataReaderWrapper_GetFieldValue_ShouldReturnTypedValue()
    {
        // Arrange
        var mockReader = new Mock<DbDataReader>();
        mockReader.Setup(r => r.GetFieldValue<int>(0)).Returns(42);
        
        var wrapper = new DataReaderWrapper(mockReader.Object);

        // Act
        var result = wrapper.GetFieldValue<int>(0);

        // Assert
        Assert.That(result, Is.EqualTo(42));
    }

    [Test]
    public void DataReaderWrapper_IsDBNull_ShouldReturnStatus()
    {
        // Arrange
        var mockReader = new Mock<DbDataReader>();
        mockReader.Setup(r => r.IsDBNull(0)).Returns(true);
        
        var wrapper = new DataReaderWrapper(mockReader.Object);

        // Act
        var result = wrapper.IsDBNull(0);

        // Assert
        Assert.That(result, Is.True);
    }

    [Test]
    public void DataReaderWrapper_Dispose_ShouldDisposeReader()
    {
        // Arrange
        var mockReader = new Mock<DbDataReader>();
        var wrapper = new DataReaderWrapper(mockReader.Object);

        // Act
        wrapper.Dispose();

        // Assert
        mockReader.Verify(r => r.Dispose(), Times.Once);
    }

    #endregion
}

====public static class TestHelpers
{
    public static benchDBcontex CreateMockDbContext()
    {
        var options = new DbContextOptionsBuilder<benchDBcontex>()
            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
            .Options;

        return new benchDBcontex(options);
    }
}



======================
The error occurs because Moq cannot mock the OpenAsync() method directly since it's an extension method from Microsoft.EntityFrameworkCore.Relational. Here's how to properly test this:

Corrected Test for Async Connection Methods
csharp
[Test]
public async Task DatabaseConnectionWrapper_ShouldOpenAndCloseConnection()
{
    // Arrange
    var mockConnection = new Mock<DbConnection>();
    var mockDatabaseFacade = new Mock<DatabaseFacade>(MockBehavior.Loose, new Mock<DbContext>().Object);
    
    // Setup extension method call
    mockConnection.Setup(c => c.OpenAsync(It.IsAny<CancellationToken>()))
        .Returns(Task.CompletedTask)
        .Verifiable();
    
    mockConnection.Setup(c => c.CloseAsync())
        .Returns(Task.CompletedTask)
        .Verifiable();
    
    var wrapper = new DatabaseConnectionWrapper(mockConnection.Object);

    // Act
    await wrapper.OpenAsync();
    await wrapper.CloseAsync();

    // Assert
    mockConnection.Verify(c => c.OpenAsync(It.IsAny<CancellationToken>()), Times.Once);
    mockConnection.Verify(c => c.CloseAsync(), Times.Once);
}
Alternative Solution Using RelationalDatabaseFacade
If the above still doesn't work, try this more comprehensive approach:

csharp
[Test]
public async Task DatabaseConnectionWrapper_ShouldOpenAndCloseConnection()
{
    // Arrange
    var mockConnection = new Mock<DbConnection>();
    var mockDbContext = new Mock<DbContext>();
    var mockDatabase = new Mock<DatabaseFacade>(mockDbContext.Object);
    
    // Setup the extension method chain
    mockDbContext.Setup(d => d.Database).Returns(mockDatabase.Object);
    mockDatabase.Setup(d => d.GetDbConnection()).Returns(mockConnection.Object);
    
    mockConnection.Setup(c => c.OpenAsync(It.IsAny<CancellationToken>()))
        .Returns(Task.CompletedTask);
    
    mockConnection.Setup(c => c.CloseAsync())
        .Returns(Task.CompletedTask);
    
    var wrapper = new DatabaseConnectionWrapper(mockConnection.Object);

    // Act
    await wrapper.OpenAsync();
    await wrapper.CloseAsync();

    // Assert
    mockConnection.Verify(c => c.OpenAsync(It.IsAny<CancellationToken>()), Times.Once);
    mockConnection.Verify(c => c.CloseAsync(), Times.Once);
}
Key Changes Made:
Added CancellationToken Parameter:

OpenAsync() typically takes a CancellationToken

Proper Task Return:

Using Task.CompletedTask for async methods

Verifiable Setup:

Added .Verifiable() to track method calls

Complete Mock Chain:

Properly mocked the EF Core extension method chain

If You Still Get NotSupportedException
Consider using a real in-memory database for integration-style testing:

csharp
[Test]
public async Task Integration_DatabaseConnectionWrapper_ShouldOpenAndCloseConnection()
{
    // Arrange
    var options = new DbContextOptionsBuilder<benchDBcontex>()
        .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
        .Options;
    
    using var dbContext = new benchDBcontex(options);
    var connection = dbContext.Database.GetDbConnection();
    var wrapper = new DatabaseConnectionWrapper(connection);

    // Act & Assert
    Assert.DoesNotThrowAsync(async () => await wrapper.OpenAsync());
    Assert.DoesNotThrowAsync(async () => await wrapper.CloseAsync());
}
This approach tests against real EF Core behavior rather than trying to mock complex extension methods.
